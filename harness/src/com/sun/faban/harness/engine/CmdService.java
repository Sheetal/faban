/* The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the License). You may not use this file except in
 * compliance with the License.
 *
 * You can obtain a copy of the License at
 * http://www.sun.com/cddl/cddl.html or
 * install_dir/legal/LICENSE
 * See the License for the specific language governing
 * permission and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * Header Notice in each file and include the License file
 * at install_dir/legal/LICENSE.
 * If applicable, add the following below the CDDL Header,
 * with the fields enclosed by brackets [] replaced by
 * your own identifying information:
 * "Portions Copyrighted [year] [name of copyright owner]"
 *
 * $Id: CmdService.java,v 1.20 2007/10/12 07:33:23 akara Exp $
 *
 * Copyright 2005 Sun Microsystems Inc. All Rights Reserved
 */
package com.sun.faban.harness.engine;

import com.sun.faban.common.Command;
import com.sun.faban.common.CommandHandle;
import com.sun.faban.common.Registry;
import com.sun.faban.common.RegistryLocator;
import com.sun.faban.harness.agent.*;
import com.sun.faban.harness.common.Config;
import com.sun.faban.harness.util.FileHelper;
import com.sun.faban.harness.util.CmdMap;
import com.sun.faban.harness.util.InterfaceProbe;
import com.sun.faban.harness.RemoteCallable;
import com.sun.faban.harness.FabanHostUnknownException;

import java.io.*;
import java.net.*;
import java.rmi.RemoteException;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This file contains the class that implements the Command service API.
 * The Command Service object is created by the Engine at the start of
 * a run and it starts up the CmdAgent applications on all the
 * machines and connects to them via RMI. In the API implementation,
 * it identifies the particular CmdAgent and passes the call along.
 *
 * The CmdAgents take care of any error messages generated by the
 * command and automatically log them to the run's error log.
 * The CmdAgent's path will include the default faban bin
 * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so
 * any faban executables will be found. Commands in any other
 * path should be invoked with the full pathname of the command.
 * The CmdAgent's environment will also include CLASSPATH set to
 * the faban lib directory to find any Java classes.
 *
 * Shell commands or any commands whose output must be re-directed
 * or piped (basically using shell) should be executed using syntax
 * such as :
 * "sh -c <command> [<args>] [> out]".
 * IMPORTANT: There should be a single CmdService object in the
 * entire framework or else multiple copies of the CmdAgent
 * application will be spawned on the target machines.
 * Therefore, this class is implemented as a Singleton.
 * No public constructors are defined and the object cannot be cloned.
 *
 * @author Ramesh Ramachandran
 * @see com.sun.faban.harness.agent.CmdAgent
 * @see com.sun.faban.harness.engine.GenericBenchmark
 */
final public class CmdService { 	// The final keyword prevents clones

    public static final int SEQUENTIAL = 1;	/* Sequential flag in FG mode*/
    public static final int PARALLEL = 2;	/* parallel flag in FG mode*/

    private static CmdService cmds;

    private ArrayList<CmdAgent> cmdp;
    private ArrayList<FileAgent> filep;
    private ArrayList<String> machinesList;	// list of all machines
    private Properties hostInterfaces;
    private Logger logger;
    private Registry registry;
    private String master;	// Name of faban master machine
    private String masterAddress; // ip of faban master machine
    private CommandHandle registryCmd;
    private String javaHome;
    private String jvmOptions;
    private HashMap<String, String> binMap = new HashMap<String, String>();
    private String rsh, agent;


    private CmdService() {
        String className = getClass().getName();
        logger = Logger.getLogger(className);

        try {
            master = (InetAddress.getLocalHost()).getHostName();
            masterAddress = (InetAddress.getLocalHost()).getHostAddress();
        } catch (Exception e) {
            logger.severe("CmdService <init> failed " + e);
            logger.log(Level.FINE, "Exception", e);
        }

        init();
    }

    /**
     * This method is the only way that an external object
     * can get a reference to the singleton CmdService.
     * This method should not be used outside engine.
     * @return reference to the single CmdService
     */
    public static CmdService getHandle() {
        if(cmds == null)
            cmds = new CmdService();
        return cmds;
    }

    /**
     *
     * @return master machine name
     */
    public String getMaster() {
        return master;
    }

    /**
     *
     * This method is called after every run to re-initialize the data
     * structures that need to change from one run to another.
     *
     */
    public void init() {
        machinesList = new ArrayList<String>();
        cmdp = new ArrayList<CmdAgent>();
        filep = new ArrayList<FileAgent>();
        hostInterfaces = new Properties();
    }

    /**
     * This method initializes the CmdAgent RMI server processes
     * on the specified set of machines
     * This method can be called multiple times to initialize multiple
     * classes of machines
     * @param hosts String[][] of machines
     * @return true if successful, false if setup failed
     *
     */
    public boolean setup(String benchName, String[][] hosts,
                         String home, String options) {

        javaHome = home;
        Config.FABAN_HOME.replace('\\', '/');
        // We need to be careful to escape properties having '\\' on win32
        String escapedHome = Config.FABAN_HOME.replace("\\", "\\\\");
        String fs = File.separatorChar == '\\' ? "\\\\" : File.separator;
        jvmOptions = "-Dfaban.home=" + escapedHome +
                " -Djava.security.policy=" + escapedHome + "config" + fs +
                "faban.policy -Djava.util.logging.config.file=" + escapedHome +
                "config" + fs + "logging.properties -Dfaban.registry.port=" +
                Config.RMI_PORT + ' ' + "-Dfaban.logging.port=" +
                Config.LOGGING_PORT;

        try {
            // Update the logging.properties file in config dir
            Properties log = new Properties();
            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +
                                                    "logging.properties");
            log.load(in);
            in.close();

            // Update if it has changed.
            if(!(log.getProperty("java.util.logging.SocketHandler.host").
                    equals(master) &&
                 log.getProperty("java.util.logging.SocketHandler.port").
                    equals(String.valueOf(Config.LOGGING_PORT)))){
                log.setProperty("java.util.logging.SocketHandler.host", master);
                log.setProperty("java.util.logging.SocketHandler.port",
                                String.valueOf(Config.LOGGING_PORT));
                FileOutputStream out = new FileOutputStream(
                        new File(Config.CONFIG_DIR + "logging.properties"));
                log.store(out, "Faban logging properties");
                out.close();
            }

        } catch(IOException e) {
            logger.log(Level.SEVERE, "Failed to initialize CmdAgent " + e, e);
        }

        // Start RMI registry and Registry
        try {

            // Create classpath with all client jars in faban/lib dir.
            // Benchmark specific stubs will be in one of the jars.
            File[] libs = (new File(Config.LIB_DIR)).listFiles();

            StringBuffer buf = new StringBuffer(" -cp ");
            for(int i = 0; i < libs.length; i++) {
                if(libs[i].isFile())
                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);
            }

            String classpath = buf.toString();

            // The registry should not consume much resources. Just don't
            // use the driver JVM options and set it to 32m - 1024m dynamic.
            // This should not be performance sensitive at all.
            String cmd = javaHome + File.separator + "bin" + File.separator +
                    "java " + jvmOptions + " -Xms32m -Xmx1024m " + classpath +
                    " com.sun.faban.common.RegistryImpl" ;

            logger.info("Starting Registry.");
            logger.fine("Starting using command " + cmd);
            Command rmiCmd = new Command(cmd);
            rmiCmd.setSynchronous(false);
            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);
            registryCmd = rmiCmd.execute();

        } catch(Exception e) {
            logger.log(Level.SEVERE, "Couldn't start Registry. " +
                    "Please check if its already running", e);
            return false;
        }

        // Now add the driver options to the JVM options. Need them after this.
        jvmOptions += ' ' + options;

        // RMI registry takes a bit of time to startup. So sleep for some time
        try {
            logger.fine("Waiting for RMI registry and Registry to startup");
            Thread.sleep(10000);
        } catch(InterruptedException e) {
        }

        try {
            registry = RegistryLocator.getRegistry(Config.RMI_PORT);
        } catch(Exception e) {
            logger.severe("Unable to connect to Registry " + e);
            logger.log(Level.FINE,  "Exception", e);
            return false;
        }

        // an agent needs to be started on the master machine
        // first since configuration of agents on other machines
        // depend on a CmdAgent running on the master machine

        // We need to scan the machines to ensure that they are not a different
        // incarnation of the master's name. If they are, switch the master to
        // use these names instead.

        // Also, we use the same loop to create a non-duplicate set of remote
        // machines. This is used later to find the interfaces to the remote
        // machine.

        InetAddress[] masterIps = null;
        try {
            masterIps = InetAddress.getAllByName(master);
        } catch (UnknownHostException e) {
            logger.log(Level.SEVERE, "Strange! Master is unknown.", e);
            return false;
        }

        HashSet<String> remoteMachines = new HashSet<String>();
        boolean isMasterSet = false;

        outer:
        for (int j = 0; j < hosts.length; j++) {
            String[] machines = hosts[j];
            for (int i = 0; i < machines.length; i++)
                try {
                    InetAddress[] machineIps =
                            InetAddress.getAllByName(machines[i]);
                    if (sameHost(masterIps, machineIps)) {
                        if (!isMasterSet) { // Set the master to the first
                                            // found master name in the list.
                            master = machines[i];
                            isMasterSet = true;
                        } else { // Set all subsequent masters to the same.
                            machines[i] = master;
                        }
                    } else {     // All remote machines go into a set.
                        remoteMachines.add(machines[i]);
                    }
                } catch (UnknownHostException e) {
                    logger.log(Level.WARNING, machines[i] + " is unknown.", e);
                }
        }

        // Next we use the command map to get the right
        // rsh command based on the undelying OS.
        try {
            binMap = CmdMap.getCmdMap(null);
            rsh = binMap.get("rsh");
            agent = binMap.get("agent") + ' ';
        } catch (Exception e) {
            logger.log(Level.WARNING, "Failed to obtain command map.",e);
        }

        if (rsh == null)
            rsh = "rsh";

        //only case in which interfaceAddress is not an address but
        //the hostname of the master machine.  used in CmdAgentImpl
        //the cmdagent on the master machine is registered under 2
        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT
        if (!machinesList.contains(master)) {
            if (!startCmdAgent(benchName, master, master))
                return false;
            machinesList.add(master);
        }

        // this is necessary in case you are on a private network
        // where the machine's private ip address is not the same as it's
        // public ip address

        // Fist check specific scripts for the arch
        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + "interface";
        File ifScript = new File(scriptPath.trim());

        // Then check script for the OS. If it exists, use it.
        // It is usually more reliable than the interface probe.
        if (!ifScript.exists()) {
            logger.finer("Could not find interface script at " +
                    ifScript.getAbsolutePath());
            scriptPath = Config.BIN_DIR + Config.OS_DIR + "interface";
            ifScript = new File(scriptPath.trim());
        }

        Map<String, String> ifMap = null;
        if (ifScript.exists()) {
            ifMap = getIfMap(remoteMachines, ifScript);
        } else {
            logger.finer("Could not find interface script at " +
                    ifScript.getAbsolutePath());
            ifScript = null;

            // If we have no interface script, we'll resort to the probe.
            // Most reliable when run as root, but buggy in parallel mode.
            // Also the interface probe needs JDK1.6 or later.
            if ("1.6".compareTo(System.getProperty("java.version")) > 0) {
                logger.severe("Could not find a way to check the interface!");
                return false;
            }

            InterfaceProbe iProbe = null;
            try {
                iProbe = new InterfaceProbe(Config.THREADPOOL);
                ifMap = iProbe.getIfMap(remoteMachines);
            } catch (SocketException e) {
                logger.log(Level.SEVERE,
                            "Could not find a way to check the interface!", e);
            }
        }

        // cycles through benchmark machines starting up agents and
        // configuring them
        for (int j = 0; j < hosts.length; j++) {
            String[] machines = hosts[j];
            for(int i = 0; i < machines.length; i++) {
                // Do not start duplicate Cmd agent
                if(machinesList.contains(machines[i]))
                    continue;

                String interfaceAddress = ifMap.get(machines[i]);

                if (interfaceAddress == null || interfaceAddress.length() == 0)
                    return false;

                if (!startCmdAgent(benchName, machines[i], interfaceAddress))
                    return false;

                // By adding the mach to the list we prevent multiple
                // agents being started on the same server
                machinesList.add(machines[i]);
            }
        }
        try {
            Thread.sleep(20000);
        } catch (InterruptedException e) {
        }
        for (int i = 0; i < machinesList.size(); i++)
            if (!getCmdAgent((String) machinesList.get(i)))
                return false;
        return true;
    }

    private Map<String, String> getIfMap(Collection<String> hosts,
                                         File ifScript) {

        HashMap<String, String> ifMap = new HashMap<String, String>();

        for (String host: hosts) {
            String interfaceAddress = null;

            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;

            logger.fine("Detecting interface: " + ifCommand);
            try {
                Process p = Runtime.getRuntime().exec(ifCommand);
                BufferedReader bufR = new BufferedReader(
                        new InputStreamReader(p.getInputStream()));

                interfaceAddress = bufR.readLine();
                if (interfaceAddress != null) {
                    interfaceAddress = interfaceAddress.trim();
                    ifMap.put(host, interfaceAddress);
                }

                int exitValue = -1;

                if (interfaceAddress != null &&
                        interfaceAddress.length() > 0) { //Read something...

                    exitValue = p.waitFor();
                    if (exitValue != 0) {
                        logger.warning("interface: Cannot reach system " +
                                host);
                        continue;
                    }
                } else { // Nothing read, check stderr
                    bufR = new BufferedReader(
                            new InputStreamReader(p.getErrorStream()));
                    logger.severe(bufR.readLine());
                    continue;
                }
            }
            catch (Exception e) {
                logger.log(Level.SEVERE,
                        "Error in executing the interface program: " +
                        ifCommand, e);
                break;
            }

            logger.config("Interface Address = " + interfaceAddress);
            logger.config("InetAddress local Host = " + masterAddress);
        }
        return ifMap;
    }

    private boolean getCmdAgent(String mach) {

        try {
            String s = Config.CMD_AGENT + "@" + mach;
            logger.fine("CmdService: Connecting to " + s);
            int retry = 1;
            CmdAgent c = (CmdAgent) registry.getService(s);
            for (; c == null && retry <= 10; retry++) {
                Thread.sleep(10000);
                logger.warning("Retry connecting to " + s + ", count " +
                                retry + '.');
                c = (CmdAgent) registry.getService(s);
            }
            if (c == null) {
                logger.severe("Could not connect to " + s);
                return(false);
            }

            cmdp.add(c);
            logger.fine("CmdService: Configuring " + s);
            // Added by Ramesh to get the real hotnames of the servers
            logger.info("CmdService: Configured " + s + " on server " + c.getHostName());
            s = Config.FILE_AGENT + "@" + mach;
            logger.fine("CmdService: Connecting to " + s);
            filep.add((FileAgent) registry.getService(s));
            return true;
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error accessing command agent on system "
                    + mach, e);
            return (false);
        }
    }

    /* start up the CmdAgent applications
    * We use a script 'cmd' which will setup the CLASSPATH before
    * invoking CmdAgent
    */
    private boolean startCmdAgent(String benchName, String mach,
                                  String interfaceAddress) {

        hostInterfaces.setProperty(mach, interfaceAddress);
        String cmdarray;

        String agentParams = mach + ' ' + interfaceAddress + ' ' +
                        masterAddress + ' ' + javaHome + ' ' + jvmOptions +
                        " faban.benchmarkName=" + benchName;
        try {
            if (mach.equals(master)) {
                cmdarray = agent + agentParams;
                logger.fine("Executing " + cmdarray);
                Command cmdAgent = new Command(cmdarray);
                cmdAgent.setSynchronous(false);
                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);
                cmdAgent.execute();
            } else { // if the machine is not the master machine, we need to
                // do an rsh and pass download instructions
                // Many times, the FABAN_URL cannot be reached by the benchmark
                // downloader. So it is better to change the URL to access
                // the master via the best interface, by ip address instead of
                // host name.

                URL fabanURL = new URL(Config.FABAN_URL);
                URL downloadURL = new URL(fabanURL.getProtocol(),
                        interfaceAddress, fabanURL.getPort(),
                        fabanURL.getFile());
                agentParams += " faban.download=" + downloadURL.toString();

                boolean agentStarted = false;

                try { // See first whether we have an agent daemon.
                    Socket socket = new Socket(mach, Config.AGENT_PORT);
                    OutputStream socketOut = socket.getOutputStream();
                    InputStream socketIn = socket.getInputStream();
                    byte[] buffer = new byte[1024];
                    socketOut.write(agentParams.getBytes());
                    socketOut.close();
                    int length = socketIn.read(buffer);
                    socketIn.close();
                    socket.close();
                    String response = new String(buffer, 0, length);
                    if ("OK".equals(response)) {
                        agentStarted = true;
                        logger.fine("Found Agend(daemon)@" + mach +
                                                    ". Registering agent.");
                    } else {
                        logger.log(Level.WARNING, "Agent(daemon)@" + mach +
                                                            ": " + response);
                    }
                } catch (ConnectException e) {
                    // We should get a ConnectException if the agent was not
                    // started in daemon mode. This should take no time.
                    logger.log(Level.FINE, "Agent(daemon)@" + mach + ": " +
                                                            e.getMessage(), e);
                } catch (IOException e) {
                    logger.log(Level.WARNING, "Agent(daemon)@" + mach + ": " +
                                                            e.getMessage(), e);
                }

                if (!agentStarted) {
                    cmdarray = rsh + ' ' + mach + ' ' + agent + agentParams;
                    logger.fine("Executing " + cmdarray);
                    Command cmdAgent = new Command(cmdarray);
                    cmdAgent.setSynchronous(false);
                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);
                    cmdAgent.execute();
                }
            }
            return true;
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Could not execute " + agent +
                                                    "on machine " + mach, e);
            return false;
        }
    }

    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {
        for (int i = 0; i < host1.length; i++) {
            for (int j = 0; j < host2.length; j++) {
                if (host1[i].equals(host2[j]))
                    return true;
            }
        }
        return false;
    }

    /**
     * Return the hostname of this machine as known to this machine
     * itself. This method is included in order to solve a Naming problem
     * related to the names of the tpcw result files to be transferred to the
     * the master machine.
     */
    public String getHostName(String machineName) {

        int index = machinesList.indexOf(machineName);
        if (index < 0)
            return machineName; // Cannot resolve
        String retVal = null;
        try {
            retVal = cmdp.get(index).getHostName();
        }
        catch (RemoteException re) {
            logger.severe("RemoteException " +
                          re.getCause());
            logger.log(Level.FINE, "Exception", re);
        }
        if (retVal == null) {
            return machineName;
        }
        return retVal;
    }

    /**
     * Executes a command from the master's command agent.
     * @param c The command to be executed
     * @return  A handle to the command
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle execute(Command c)
            throws IOException, InterruptedException, RemoteException {
        return execute(master, c);
    }

    /**
     * Executes a command from the remote command agent.
     * @param machine The target machine to execute the command
     * @param c The command to be executed
     * @return  A handle to the command
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle execute(String machine, Command c)
            throws IOException, InterruptedException, RemoteException {
        return findCmdAgent(machine).execute(c);
    }

    /**
     * Executes a command from the remote command agent.
     * @param machines The target machines to execute the command
     * @param c The command to be executed
     * @return  Handles to the command on each of the target machines
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle[] execute(String[] machines, Command c)
            throws IOException, InterruptedException, RemoteException {
        CommandHandle[] result = new CommandHandle[machines.length];
        for (int i = 0; i < machines.length; i++)
            result[i] = findCmdAgent(machines[i]).execute(c);
        return result;
    }

    /**
     * Executes a java command from the master's command agent.
     * @param c The command to be executed
     * @return  A handle to the command
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle java(Command c)
            throws IOException, InterruptedException, RemoteException {
        return java(master, c);
    }
    /**
     * Executes a java command from the remote command agent.
     * @param machine The target machine to execute the command
     * @param c The command to be executed
     * @return  A handle to the command
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle java(String machine, Command c)
            throws IOException, InterruptedException, RemoteException {
        return findCmdAgent(machine).java(c);
    }

    /**
     * Executes a java command from the remote command agent.
     * @param machines The target machines to execute the command
     * @param c The command to be executed
     * @return  Handles to the command on each of the target machines
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle[] java(String[] machines, Command c)
            throws IOException, InterruptedException, RemoteException {
        CommandHandle[] result = new CommandHandle[machines.length];
        for (int i = 0; i < machines.length; i++)
            result[i] = findCmdAgent(machines[i]).java(c);
        return result;
    }

    public <V extends Serializable> V
            execute(String machine, RemoteCallable<V> callable)
            throws Exception {
        return findCmdAgent(machine).exec(callable);
    }

    public <V extends Serializable> List<V>
            execute(String[] machines, RemoteCallable<V> callable)
            throws Exception {

        ArrayList<V> rl = new ArrayList<V>();
        for (int i = 0; i < machines.length; i++)
            rl.add(findCmdAgent(machines[i]).exec(callable));
        return rl;
    }


    /**
     * Start commands sequentially in foreground on machines
     * The command string should include all stdin, stdout, stderr
     * redirections (if any). Note that files referred in the command
     * should be on the machine on which the command is run.
     * The 'copy' method can be used to transfer files to remote machines.
     * @param machines on which command should be started
     * @param cmd command to be started
     * @param seq flag to indicate if commands should be sequential or parallel
     * @param priority (default or higher priority) for command
     * @return true if all commands completed successfully, else false
     * @see #copy (String, String, String, String, boolean)
     */
    public boolean start(String machines[], String cmd, int seq,
                         int priority) throws Exception {

        boolean exitcode = true;


        for (int i = 0; i<machines.length; i++)
            logger.fine("Starting command = " + cmd +" on machine " + machines[i]);

        if (seq == SEQUENTIAL) {
            /* Start cmd on each m/c in foreground */
            for (int i = 0; i < machines.length; i++) {
                if (findCmdAgent(machines[i]).start(cmd, priority) == false)
                    exitcode = false;
            }
        }
        else if (seq == PARALLEL) {
            /* Start cmd on each m/c in parallel, then wait for all */
            String ident = "Generated";
            for (int i = 0; i < machines.length; i++)
                findCmdAgent(machines[i]).start(cmd, ident, priority);
            for (int i = 0; i < machines.length; i++)
                if (findCmdAgent(machines[i]).wait(ident) == false)
                    exitcode = false;
        }
        return(exitcode);
    }


    /**
     * Start a command on a single machine
     */
    public boolean start(String machine, String command, int seq,
                         int priority) throws Exception {

        String m[] = new String[1];
        m[0] = machine;

        return(start(m, command, seq, priority));
    }

    /**
     * Start commands in background
     *
     * @param machines on which command should be started
     * @param cmd command to be started
     * @param ident to identify this command later
     * @param priority (default or higher priority) for command
     */
    public void start(String machines[], String cmd, String ident,
                      int priority) throws Exception {
        for (int i = 0; i < machines.length; i++) {
            if ((machines[i] == null) || (machines[i].equals("")))
                continue;
            findCmdAgent(machines[i]).start(cmd, ident, priority);
        }
    }

    /**
     * Start command in background and wait for the
     * specified message
     * @param machines on which command should be started
     * @param cmd command to be started
     * @param ident to identify this command later null if you don't want to do wait
     *              or kill the process when the cmdAgent exits.
     * @param msg message message to which wait for
     * @param priority (default or higher priority) for command
     */
    public void start(String machines[], String cmd, String ident, String msg,
                      int priority) throws Exception {

        for (int i = 0; i < machines.length; i++) {

            if ((machines[i] == null) || (machines[i].equals("")))
                continue;

            boolean ret = findCmdAgent(machines[i]).
                    start(cmd, ident, msg, priority);
            if(ret)
                logger.fine("Started command " + cmd + " on machine " + machines[i]);
            else
                logger.severe("command " + cmd + " on machine " + machines[i] + " failed");
        }
    }

    /**
     * Start a command in background on a single machine
     */
    public void start(String machine, String command, String ident,
                      int priority ) throws Exception {
        String m[] = new String[1];
        m[0] = machine;
        start(m, command, ident, priority);
    }


    /**
     * Start a  command in background and returning the first line of output.
     *
     * @param machine name of the machine on which to start the command
     * @param command to start
     * @param ident identifier to associate with this command
     * @param priority in which to run command
     * @return String the first line of output from the command
     */
    public String startAndGetOneOutputLine(String machine, String command,
                                           String ident, int priority)
            throws Exception {

        logger.info("starting command = "
                    + command + " on machine = " + machine);
        String retVal = findCmdAgent(machine).startAndGetOneOutputLine(
                                                command, ident, priority);
        return retVal;
    }



    /**
     * Start a command in foreground and returning the stdout.
     *
     * @param machine name of the machine on which to start the command
     * @param command to start
     * @param priority in which to run command
     * @return String the standard output from the command
     */
    public String startAndGetStdOut (String machine, String command, int priority)
            throws Exception {

        String retVal = findCmdAgent(machine).
                                        startAndGetStdOut(command, priority);
        return retVal;
    }



    public void startJavaCmd(String machines[], String cmd,
                             String ident, String env[]) throws Exception {


        for (int i = 0; i < machines.length; i++) {
            if ((machines[i] == null) || (machines[i].equals(""))) {
                continue;
            }
            logger.fine("Starting JAVA with " + cmd + " on " + machines[i]);
            findCmdAgent(machines[i]).startJavaCmd(cmd, ident, env);
        }
    }

    /**
     * Start the agent on a single machine
     */
    public boolean startAgent(String machine, Class agentClass, String identifier) throws Exception {

        String m[] = new String[1];
        m[0] = machine;

        return(startAgent(m, agentClass, identifier));
    }

    /**
     * Start Agent in the specified machines.
     *
     * @param machines on which command should be started
     * @param agentClass Impl Class of the agent to be started
     * @param identifier to identify this agent later
     */
    public boolean startAgent(String machines[], Class agentClass, String identifier) throws Exception {
        boolean result = true;

        for (int i = 0; i < machines.length; i++) {
            if ((machines[i] == null) || (machines[i].equals(""))) {
                continue;
            }
            //Change the identifier to agent@host
            result = result && findCmdAgent(machines[i]).
                    startAgent(agentClass, identifier + "@" + machines[i]);
        }
        return result;
    }


    /**
     * Wait for command started earlier in background
     * This method calls wait on all the CmdAgent objects for
     * the listed machines
     *
     * @param machine on which to wait
     * @param ident used to identify command in 'start' call
     * @return true if command finished succesfully
     */
    public boolean wait(String machine, String ident) throws Exception {
        boolean exitcode = true;
        logger.info("Waiting for " + ident + " to complete ");
        if (findCmdAgent(machine).wait(ident) == false)
            exitcode = false;
        return(exitcode);
    }

    /**
     * Wait for command started earlier in background
     * This method calls wait on all the CmdAgent objects for
     * the listed machines
     *
     * @param machines on which to wait
     * @param ident used to identify command in 'start' call
     * @return true if command finished succesfully on all machines
     */
    public boolean wait(String machines[], String ident) throws Exception {
        boolean exitcode = true;
        for (int i = 0; i < machines.length; i++) {
            if(wait(machines[i], ident) == false)
                exitcode = false;
        }
        return(exitcode);
    }

    /**
     * Kill command started earlier in background
     * This method calls kill on all the CmdAgent objects for
     * the listed machines
     * @param machines on which to issue kill
     * @param ident used to identify command in 'start' call
     */
    public void kill(String machines[], String ident) {
        try {
            for (int i = 0; i < machines.length; i++)
                findCmdAgent(machines[i]).kill(ident);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Failed to kill " + ident, e);
        }
    }


    /**

     * Kill command started earlier in background using the killem script.
     * This method calls killem on all the CmdAgent objects for
     * the listed machines.
     * @param machines on which to issue kill
     * @param ident identifier if any if this process was previously started
     *              through the CmdService.
     * @param processString search string to grep the process while killing
     *                      (same as in killem)
     * @param sigNum the signal number to be used to kill.
     *
     */
    public void killem(String machines[], String ident, String processString, int sigNum) {
        try {
            for (int i = 0; i < machines.length; i++) {
                findCmdAgent(machines[i]).killem(ident, processString, sigNum);
                logger.info("killed " + processString +
                        " on machine " + machines[i]);
            }
        } catch (Exception e) { }
    }

    /**
     * Gets a property from a given file
     * @param machine The machine name
     * @param propFile The property file name
     * @param propName The property key name
     * @return The property value
     * @throws java.io.IOException If there is an error accessing the config file
     */
    public String getProperty(String machine, String propFile, String propName)
            throws IOException {
        return findFileAgent(machine).getProperty(propFile, propName);
    }


    /**
     * Kill all commands currently running and cleanup
     * This method is called when a run must be aborted
     * or at the end of a benchmark run.
     */
    public void kill() {
        int i = 0;
        try {
            for (i = 0; i < cmdp.size(); i++) {
                logger.info("killing CmdAgent@" + machinesList.get(i));
                cmdp.get(i).kill();
            }
            cmdp.clear();
            filep.clear();
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Kill Failed for CmdAgent@" +
                    machinesList.get(i), e);
        } finally {
            //Exiting Registry
            if (registryCmd != null) {
                int retry = 0;
                for (; retry < 20; retry++)
                    try {
                        registryCmd.destroy();
                        Thread.sleep(1000);
                        int exitValue = registryCmd.exitValue();
                        logger.finer("Registry exited with exit value " +
                                exitValue + '.');
                        break;
                    } catch (InterruptedException e) {
                        logger.log(Level.WARNING, "Interrupted waiting for " +
                                "registry to terminate. " +
                                "Cannot verify termination status.", e);
                    } catch (RemoteException e) {
                        logger.log(Level.SEVERE, "Caught RemoteException on " +
                                "local CommandHandle destroy for Registry. " +
                                "Please report bug.", e);
                    } catch (IllegalThreadStateException e) {
                        logger.log(Level.FINER,
                                "Registry did not terminate! ", e);
                    }
                if (retry == 20)
                    logger.severe("Registry did not terminate " +
                                "after 20 termination attempts, giving up! " +
                                "Subsequent runs may have problems.");

            }
        }
    }

    /**
     * Pushes a local file on the Faban master to the remote host.
     * @param srcfile The source file name
     * @param destmachine The destination machine
     * @param destfile The destination file name
     * @return true if successful, false otherwise
     */
    public synchronized boolean push(String srcfile,
                                     String destmachine, String destfile) {
        int didx = machinesList.indexOf(destmachine);
        if (didx == -1)
            throw new FabanHostUnknownException(
                    "Host " + destmachine + " not found!");
        if (srcfile.equals(destfile)){
            try {
                CmdAgent master = (CmdAgent)
                                        registry.getService(Config.CMD_AGENT);
                String src = master.getHostName();
                String dest = cmdp.get(didx).getHostName();
                if (dest == src)
                    return true;
            } catch (RemoteException e) {
                logger.log(Level.SEVERE, "CmdService: Pushing - CmdAgent " +
                           "getHostName exception", e);
                return false;
            }
        }

        FileAgent destf = filep.get(didx);
        try {
            FileService destfilep = destf.open(destfile, FileAgent.WRITE);
            byte[] content = FileHelper.getContent(srcfile);
            destfilep.write(content);
            destfilep.close();
        } catch (FileServiceException e) {
            logger.log(Level.SEVERE, "CmdService: Pushing - " +
                    "exception writing file " + destfile, e);
            return false;
        } catch (IOException e) {
            logger.log(Level.SEVERE, "CmdService: Pushing - " +
                    "exception reading file " + srcfile, e);
            return false;
        }
        return true;
    }
    /**
     * Copy a file from one remote machine to another
     * This method essentially does the work of 'rcp'
     * using the FileAgents on the machines
     * @param srcmachine - Name of source machine
     * @param destmachine - Name of destination machine
     * @param srcfile - Name of source file
     * @param destfile - Name of destination file
     * @param append to dest file or overwrite it
     * @return true/false if copy was successful/failed
     */
    public synchronized boolean copy(String srcmachine, String destmachine,
                                     String srcfile, String destfile,
                                     boolean append) {

        FileAgent srcf, destf = null;
        FileService srcfilep = null, destfilep = null;
        int sidx = machinesList.indexOf(srcmachine);
        int didx = machinesList.indexOf(destmachine);
        byte[] buf;
        if (sidx == didx && srcfile.equals(destfile))
            return(true);

        if (srcfile.equals(destfile)){
            try{
                String dest = cmdp.get(didx).getHostName();
                String src = cmdp.get(sidx).getHostName();
                if (dest == src)
                    return true;
            } catch (Exception e) {
                logger.severe("CmdService: Copying - CmdAgent getHostName exception");
                logger.log(Level.FINE, "Exception", e);
            }
        }
        logger.fine("CmdService: Copying " + srcfile + " from " + srcmachine
                + " to " + destfile + " in " + destmachine);

        srcf = filep.get(sidx);
        destf = filep.get(didx);
        try {
            srcfilep = srcf.open(srcfile, FileAgent.READ);
            if (append)
                destfilep = destf.open(destfile, FileAgent.APPEND);
            else
                destfilep = destf.open(destfile, FileAgent.WRITE);

            // Read from src and write to dest.
            buf = srcfilep.read();
            destfilep.write(buf);

            srcfilep.close();
            destfilep.close();
        } catch (Exception ie) {
            logger.severe("CmdService: Could not copy " + srcmachine +
                              ":" + srcfile + " to " + destmachine + ":" + destfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
        return true;
    }

    public synchronized boolean move(String srcmachine, String destmachine,
                                     String srcfile, String destfile,
                                     boolean append) {
        // First copy the file then delete
        try {
            if(this.copy(srcmachine, destmachine, srcfile, destfile, append)) {
                FileAgent srcf = null;
                int sidx = machinesList.indexOf(srcmachine);
                int didx = machinesList.indexOf(destmachine);
                if (sidx == didx && srcfile.equals(destfile))
                    return(true);
                srcf = filep.get(sidx);
                return srcf.removeFile(srcfile);
            }
        }
        catch(Exception ie) {
            logger.severe("CmdService: Could not move " + srcmachine +
                        ":" + srcfile + " to " + destmachine + ":" +
                        destfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
        return false;
    }

    public String getTmpDir(String machine) {
        try {
            return findCmdAgent(machine).getTmpDir();
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }

    private CmdAgent findCmdAgent(String machine) {
        if (machine == null || machine.length() == 0)
            throw new IllegalArgumentException(
                    "Machine cannot be null or zero length");
        int index = machinesList.indexOf(machine);
        if (index == -1)
            throw new FabanHostUnknownException(
                    "Host " + machine + " not found!");
        return cmdp.get(index);
    }

    private FileAgent findFileAgent(String machine) {
        if (machine == null || machine.length() == 0)
            throw new IllegalArgumentException(
                    "Machine cannot be null or zero length");
        int index = machinesList.indexOf(machine);
        if (index == -1)
            throw new FabanHostUnknownException(
                    "Host " + machine + " not found!");
        return filep.get(index);
    }


    public synchronized boolean delete(String srcmachine, String srcfile) {
        try {
            return findFileAgent(srcmachine).removeFile(srcfile);
        } catch (Exception ie) {
                logger.severe("CmdService: Could not delete " + srcmachine +
                        ":" + srcfile);
            logger.log(Level.FINE, "Exception", ie);
            return false;
        }
    }


    /**
     * Copy a file from one remote machine to a stream on the master.
     * This method essentially does the work of 'rcp'
     * using the FileAgents on the machines
     * @param srcmachine - Name of source machine
     * @param srcfile - Name of source file
     * @param stream The stream to copy the content to
     * @return true/false if copy was successful/failed
     */
    public synchronized boolean copyToStream(String srcmachine, String srcfile, 
                                             OutputStream stream) {
        FileService srcfilep = null;
        byte[] buf = null;

        FileAgent srcf = findFileAgent(srcmachine);
        try {
            srcfilep = srcf.open(srcfile, FileAgent.READ);

            // Now loop, reading from src and writing to dest
            while (true) {
                buf = srcfilep.readBytes(1000000);
                //	logger.info("           Read " + buf);
                //	logger.info(buf);
                //		logger.info(buf.length);
                stream.write(buf);
                if (buf.length < 1000000) {
                    break;
                }
            }

            srcfilep.close();
        } catch (Exception ie) {
            logger.severe("CmdService: Could not copy " + srcmachine +
                          ":" + srcfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
        return(true);
    }


    /**
     * Copy a file from one remote machine to another
     * This method essentially does the work of 'rcp'
     * using the FileAgents on the machines
     * @param srcmachine - Name of source machine
     * @param destmachine - Name of destination machine
     * @param srcfile - Name of source file
     * @param destfile - Name of destination file
     * @param append to dest file or overwrite it
     * @return true/false if copy was successful/failed
     */
    public synchronized boolean copyBytes(String srcmachine,
                                          String destmachine,
                                          String srcfile, String destfile,
                                          boolean append) {
        FileAgent srcf, destf = null;
        FileService srcfilep = null, destfilep = null;
        int sidx = machinesList.indexOf(srcmachine);
        int didx = machinesList.indexOf(destmachine);
        byte[] buf = new byte[1000000];

        //logger.info("CmdService: Copying " + srcfile + " to " + destfile);
        //logger.info("CmdService: Copying from " + srcmachine + " to " + destmachine);
        if (sidx == didx && srcfile.equals(destfile))
            return(true);
        srcf = filep.get(sidx);
        destf = filep.get(didx);
        try {
            srcfilep = srcf.open(srcfile, FileAgent.READ);
            if (append)
                destfilep = destf.open(destfile, FileAgent.APPEND);
            else
                destfilep = destf.open(destfile, FileAgent.WRITE);

            // Now loop, reading from src and writing to dest
            while (true) {
                buf = srcfilep.readBytes(1000000);
                //	logger.info("           Read " + buf);
                //	logger.info(buf);
                //		logger.info(buf.length);
                destfilep.writeBytes(buf, 0 , buf.length);
                if (buf.length < 1000000) {
                    break;
                }
            }

            srcfilep.close();
            destfilep.close();
        } catch (Exception ie) {
            logger.severe("CmdService: Could not copy " + srcmachine +
                          ":" + srcfile + " to " + destmachine + ":" +
                          destfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
        return(true);
    }


    /**
     *
     * The hostInterfaces Properties object stores mappings of machine name
     * in the benchmark configuration to the corresponding interface of the
     * master machine used to connect to that machine.
     *
     * @return Properties - the hostInterfaces oject.
     */
    public Properties getHostInterfaces() {
        return hostInterfaces;
    }

    /**
     * Set the Log level for Agents
     * @param name Logger name
     * @param level Log level
     */
    public void setLogLevel(String name, Level level) {
        int i = 0;
        try {
            for (i = 0; i < cmdp.size(); i++) {
                cmdp.get(i).setLogLevel(name, level);
            }
        } catch (Exception e) {
            logger.severe(" setLogLevel Failed for CmdAgent@" + machinesList.get(i));
            logger.log(Level.FINE, "Exception", e);
        }
    }

    Registry getRegistry() {
        return registry;
    }

    /**
     * Checks whether the given remote file exists.
     * @param hostName The host name to check.
     * @param fileName The file name to test.
     * @return true if exists, false otherwise.
     */
    public boolean doesFileExist(String hostName, String fileName) {
        try {
            return findFileAgent(hostName).doesFileExist(fileName);
        } catch (Exception ie) {
                logger.log(Level.SEVERE, "CmdService: Could not check " +
                        hostName + ":" + fileName, ie);
            return false;
        }
    }

    /**
     * Checks whether the given remote file exists and is a normal file.
     * @param hostName The host name to check.
     * @param fileName The file name to test.
     * @return true if file is a normal file, false otherwise.
     */
    public boolean isFile(String hostName, String fileName) {
        try {
            return findFileAgent(hostName).isFile(fileName);
        } catch (Exception ie) {
                logger.log(Level.SEVERE, "CmdService: Could not check " +
                        hostName + ":" + fileName, ie);
            return false;
        }
    }

    /**
     * Checks whether the given remote file exists and is a directory.
     * @param hostName The host name to check.
     * @param fileName The file name to test.
     * @return true if file is a directory, false otherwise.
     */
    public boolean isDirectory(String hostName, String fileName) {
        try {
            return findFileAgent(hostName).isDirectory(fileName);
        } catch (Exception ie) {
                logger.log(Level.SEVERE, "CmdService: Could not check " +
                        hostName + ":" + fileName, ie);
            return false;
        }
    }
}
