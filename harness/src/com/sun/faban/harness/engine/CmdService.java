/* The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the License). You may not use this file except in
 * compliance with the License.
 *
 * You can obtain a copy of the License at
 * http://www.sun.com/cddl/cddl.html or
 * install_dir/legal/LICENSE
 * See the License for the specific language governing
 * permission and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * Header Notice in each file and include the License file
 * at install_dir/legal/LICENSE.
 * If applicable, add the following below the CDDL Header,
 * with the fields enclosed by brackets [] replaced by
 * your own identifying information:
 * "Portions Copyrighted [year] [name of copyright owner]"
 *
 * $Id: CmdService.java,v 1.6 2006/07/28 07:33:46 akara Exp $
 *
 * Copyright 2005 Sun Microsystems Inc. All Rights Reserved
 */
package com.sun.faban.harness.engine;

import com.sun.faban.common.Command;
import com.sun.faban.common.CommandHandle;
import com.sun.faban.common.Registry;
import com.sun.faban.common.RegistryLocator;
import com.sun.faban.harness.agent.CmdAgent;
import com.sun.faban.harness.agent.FileAgent;
import com.sun.faban.harness.agent.FileService;
import com.sun.faban.harness.common.Config;

import java.io.*;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This file contains the class that implements the Command service API.
 * The Command Service object is created by the Engine at the start of
 * a run and it starts up the CmdAgent applications on all the
 * machines and connects to them via RMI. In the API implementation,
 * it identifies the particular CmdAgent and passes the call along.
 *
 * The CmdAgents take care of any error messages generated by the
 * command and automatically log them to the run's error log.
 * The CmdAgent's path will include the default faban bin
 * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so
 * any faban executables will be found. Commands in any other
 * path should be invoked with the full pathname of the command.
 * The CmdAgent's environment will also include CLASSPATH set to
 * the faban lib directory to find any Java classes.
 *
 * Shell commands or any commands whose output must be re-directed
 * or piped (basically using shell) should be executed using syntax
 * such as :
 * "sh -c <command> [<args>] [> out]".
 * IMPORTANT: There should be a single CmdService object in the
 * entire framework or else multiple copies of the CmdAgent
 * application will be spawned on the target machines.
 * Therefore, this class is implemented as a Singleton.
 * No public constructors are defined and the object cannot be cloned.
 *
 * @author Ramesh Ramachandran
 * @see com.sun.faban.harness.agent.CmdAgent
 * @see com.sun.faban.harness.engine.GenericBenchmark
 */
final public class CmdService { 	// The final keyword prevents clones

    public static final int SEQUENTIAL = 1;	/* Sequential flag in FG mode*/
    public static final int PARALLEL = 2;	/* parallel flag in FG mode*/

    private static CmdService cmds;

    private ArrayList cmdp, filep;
    private ArrayList machinesList;	// list of all machines
    private Properties hostInterfaces;
    private Logger logger;
    private Registry registry;
    private String master;	// Name of faban master machine
    private String masterAddress; // ip of faban master machine
    private CommandHandle rmi;
    private String javaHome;
    private String jvmOptions;


    private CmdService() {
        String className = getClass().getName();
        logger = Logger.getLogger(className);

        try {
            master = (InetAddress.getLocalHost()).getHostName();
            masterAddress = (InetAddress.getLocalHost()).getHostAddress();
        } catch (Exception e) {
            logger.severe("CmdService <init> failed " + e);
            logger.log(Level.FINE, "Exception", e);
        }

        init();
    }

    /**
     * This method is the only way that an external object
     * can get a reference to the singleton CmdService.
     * This method should not be used outside engine.
     * @return reference to the single CmdService
     */
    public static CmdService getHandle() {
        if(cmds == null)
            cmds = new CmdService();
        return cmds;
    }

    /**
     *
     * @return master machine name
     */
    public String getMaster() {
        return master;
    }

    /**
     *
     * This method is called after every run to re-initialize the data
     * structures that need to change from one run to another.
     *
     */
    public void init() {
        machinesList = new ArrayList();
        cmdp = new ArrayList();
        filep = new ArrayList();
        hostInterfaces = new Properties();
    }

    /**
     * This method initializes the CmdAgent RMI server processes
     * on the specified set of machines
     * This method can be called multiple times to initialize multiple
     * classes of machines
     * @param hosts String[][] of machines
     * @return true if successful, false if setup failed
     *
     */
    public boolean setup(String benchName, String[][] hosts, String home, String options) {

        javaHome = home;
        jvmOptions = "-Djava.security.policy=" + Config.FABAN_HOME + "config" + File.separator +
                "faban.policy -Djava.util.logging.config.file=" + Config.FABAN_HOME + "config" +
                File.separator + "logging.properties -Dfaban.home=" + Config.FABAN_HOME +
                " -Dfaban.registry.port=" + Config.RMI_PORT + " -Dfaban.logging.port=" +
                Config.LOGGING_PORT;

        try {
            // Update the logging.properties file in config dir
            Properties log = new Properties();
            FileInputStream in = new FileInputStream(Config.CONFIG_DIR + "logging.properties");
            log.load(in);
            in.close();

            // Update if it has changed.
            if(!(log.getProperty("java.util.logging.SocketHandler.host").equals(master) &&
                 log.getProperty("java.util.logging.SocketHandler.port").equals(String.valueOf(Config.LOGGING_PORT)))){
                log.setProperty("java.util.logging.SocketHandler.host", master);
                log.setProperty("java.util.logging.SocketHandler.port", String.valueOf(Config.LOGGING_PORT));
                FileOutputStream out = new FileOutputStream(new File(Config.CONFIG_DIR + "logging.properties"));
                log.store(out, "Faban logging properties");
                out.close();
            }

        } catch(IOException e) {
            logger.log(Level.SEVERE, "Failed to initialize CmdAgent " + e, e);
        }

        // Start RMI registry and Registry
        try {

            // Create classpath with all client jars in faban/lib dir.
            // Benchmark specific stubs will be in one of the jars.
            File[] libs = (new File(Config.LIB_DIR)).listFiles();

            StringBuffer buf = new StringBuffer(" -cp ");
            for(int i = 0; i < libs.length; i++) {
                if(libs[i].isFile())
                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);
            }

            String classpath = buf.toString();

            // The registry should not consume much resources. Just don't
            // use the driver JVM options and set it to 32m - 1024m dynamic.
            // This should not be performance sensitive at all.
            String cmd = javaHome + File.separator + "bin" + File.separator +
                    "java " + jvmOptions + " -Xms32m -Xmx1024m " + classpath +
                    " com.sun.faban.common.RegistryImpl" ;

            logger.info("Starting Registry.");
            logger.fine("Starting using command " + cmd);
            Command rmiCmd = new Command(cmd);
            rmiCmd.setSynchronous(false);
            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);
            rmi = rmiCmd.execute();

        } catch(Exception e) {
            logger.log(Level.SEVERE, "Couldn't start Registry. " +
                    "Please check if its already running", e);
            return false;
        }

        // Now add the driver options to the JVM options. Need them after this.
        jvmOptions += ' ' + options;

        // RMI registry takes a bit of time to startup. So sleep for some time
        try {
            logger.fine("Waiting for RMI registry and Registry to startup");
            Thread.sleep(10000);
        } catch(InterruptedException e) {
        }

        try {
            registry = RegistryLocator.getRegistry(Config.RMI_PORT);
        } catch(Exception e) {
            logger.severe("Unable to connect to Registry " + e);
            logger.log(Level.FINE,  "Exception", e);
            return false;
        }

        // an agent needs to be started on the master machine
        // first since configuration of agents on other machines
        // depend on a CmdAgent running on the master machine

        // We need to scan the machines to ensure that they are not a different
        // incarnation of the master's name. If they are, switch the master to
        // use these names instead.

        InetAddress[] masterIps = null;
        try {
            masterIps = InetAddress.getAllByName(master);
        } catch (UnknownHostException e) {
            logger.log(Level.SEVERE, "Strange! Master is unknown.", e);
            return false;
        }
        outer:
        for (int j = 0; j < hosts.length; j++) {
            String[] machines = hosts[j];
            for (int i = 0; i < machines.length; i++)
                try {
                    InetAddress[] machineIps =
                            InetAddress.getAllByName(machines[i]);
                    if (sameHost(masterIps, machineIps)) {
                        master = machines[i];
                        break outer;
                    }
                } catch (UnknownHostException e) {
                    logger.log(Level.WARNING, machines[i] + " is unknown.", e);
                }
        }


        //only case in which interfaceAddress is not an address but
        //the hostname of the master machine.  used in CmdAgentImpl
        //the cmdagent on the master machine is registered under 2
        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT
        if (!machinesList.contains(master)) {
            if (!startCmdAgent(benchName, master, master))
                return false;
            machinesList.add(master);
        }

        // cycles through benchmark machines starting up agents and
        // configuring them
        for (int j = 0; j < hosts.length; j++) {
            String[] machines = hosts[j];
            for(int i = 0; i < machines.length; i++) {
                // Do not start duplicate Cmd agent
                if(machinesList.contains(machines[i])) {
                    continue;
                }

                String interfaceAddress = null;

                // this is necessary in case you are on a private network
                // where the machine's private ip address is not the same as it's
                // public ip address

                // Fist check specific scripts for the arch
                String osName = System.getProperty("os.name");
                String scriptPath = Config.BIN_DIR + osName +
                        File.separator + System.getProperty("os.arch") +
                        File.separator + "interface";
                File ifScript = new File(scriptPath.trim());

                // Then check script for the OS.
                if (!ifScript.exists()) {
                    logger.finer("Could not find interface script at " +
                            ifScript.getAbsolutePath());
                    scriptPath = Config.BIN_DIR + osName +
                            File.separator + "interface";
                    ifScript = new File(scriptPath.trim());
                }

                if (!ifScript.exists()) {
                    logger.severe("Could not find interface script at " +
                            ifScript.getAbsolutePath());
                    return false;
                }

                String ifCommand = ifScript.getAbsolutePath() + ' ' + machines[i];

                logger.fine("Detecting interface: " + ifCommand);
                try {
                    Process p = Runtime.getRuntime().exec(ifCommand);
                    BufferedReader bufR = new BufferedReader(
                            new InputStreamReader(p.getInputStream()));

                    interfaceAddress = bufR.readLine().trim();
                    int exitValue = -1;

                    if (interfaceAddress != null &&
                        interfaceAddress.length() > 0) { //Read something...

                        exitValue = p.waitFor();
                        if (exitValue != 0) {
                            logger.severe("interface: Cannot reach system " +
                                          machines[i]);
                            return false;
                        }
                    } else { // Nothing read, check stderr
                        bufR = new BufferedReader(
                                new InputStreamReader(p.getErrorStream()));
                        logger.severe(bufR.readLine());
                        return false;
                    }
                }
                catch (Exception e) {
                    logger.log(Level.SEVERE,
                            "Error in executing the interface program: " +
                            ifCommand, e);
                    return false;
                }

                logger.config("Interface Address = " + interfaceAddress);
                logger.config("InetAddress local Host = " + masterAddress);

                if (!startCmdAgent(benchName, machines[i], interfaceAddress)) {
                    return false;
                }
                // By adding the mach to the list we prevent multiple
                // agents being started on the same server
                machinesList.add(machines[i]);
            }
        }
        try {
            Thread.sleep(20000);
        } catch (InterruptedException e) {
        }
        for (int i = 0; i < machinesList.size(); i++)
            if (!getCmdAgent((String) machinesList.get(i)))
                return false;
        return true;
    }

    private boolean getCmdAgent(String mach) {

        try {
            String s = Config.CMD_AGENT + "@" + mach;
            logger.fine("CmdService: Connecting to " + s);
            int retry = 1;
            CmdAgent c = (CmdAgent) registry.getService(s);
            for (; c == null && retry <= 10; retry++) {
                Thread.sleep(10000);
                logger.warning("Retry connecting to " + s + ", count " +
                                retry + '.');
                c = (CmdAgent) registry.getService(s);
            }
            if (c == null) {
                logger.severe("Could not connect to " + s);
                return(false);
            }

            cmdp.add(c);
            logger.fine("CmdService: Configuring " + s);
            // Added by Ramesh to get the real hotnames of the servers
            logger.info("CmdService: Configured " + s + " on server " + c.getHostName());
            s = Config.FILE_AGENT + "@" + mach;
            logger.fine("CmdService: Connecting to " + s);
            filep.add(registry.getService(s));
            return true;
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error accessing command agent on system "
                    + mach, e);
            return (false);
        }
    }

    /* start up the CmdAgent applications
    * We use a script 'cmd' which will setup the CLASSPATH before
    * invoking CmdAgent
    */
    private boolean startCmdAgent(String benchName, String mach, String interfaceAddress) {

        hostInterfaces.setProperty(mach, interfaceAddress);
        String cmdarray;
        if (mach.equals(master)) {
            cmdarray = Config.CMD_SCRIPT + mach + ' ' + interfaceAddress + ' ' +
                    masterAddress + ' ' + javaHome + " faban.benchmarkName=" +
                    benchName + ' ' + jvmOptions;
        } else { // if the machine is not the master machine, we need to
                 // do an rsh and pass download instructions
            cmdarray = "rsh -n " + mach + Config.CMD_SCRIPT + mach + ' ' +
                    interfaceAddress + ' ' + masterAddress + ' ' + javaHome +
                    " faban.benchmarkName=" + benchName + " faban.download=" +
                    Config.FABAN_URL + ' ' + jvmOptions;
        }

        try {
            logger.fine("CmdService: Executing " + cmdarray);

            Process p = Runtime.getRuntime().exec(cmdarray);

            if(p != null) {
                StringBuffer buffer = new StringBuffer();
                byte[] b = new byte[1024];

                // We do not expect a lot of output from the cmdAgent
                // so we do not need a separate thread to do the reading.

                // First process the error stream
                InputStream is = p.getErrorStream();
                int size = is.read(b);
                while (size > -1) {
                    if (size > 0)
                        buffer.append(new String(b, 0, size));
                    size = is.read(b);
                }
                is.close();
                
                if (buffer.length() > 0)
                    logger.warning("stderr starting command agent on " + mach +
                            ":\n" + buffer.toString());

                // Then process the input stream
                buffer.setLength(0);
                is = p.getInputStream();
                size = is.read(b);
                while (size > -1) {
                    if (size > 0)
                        buffer.append(new String(b, 0, size));
                    size = is.read(b);
                }
                is.close();

                if (buffer.length() > 0)
                    logger.info("stdout starting command agent on " + mach +
                            ":\n" + buffer.toString());
                return true;
            }
            // Else
            logger.severe("Could not execute "
                          + Config.CMD_SCRIPT + " on machine " + mach);
            return false;
        } catch(IOException e) {
            logger.severe("Could not execute "
                          + Config.CMD_SCRIPT + " on machine " + mach);
            logger.log(Level.FINE, "Exception", e);
            return false;
        }
    }

    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {
        for (int i = 0; i < host1.length; i++) {
            for (int j = 0; j < host2.length; j++) {
                if (host1[i].equals(host2[j]))
                    return true;
            }
        }
        return false;
    }

    /**
     * Return the hostname of this machine as known to this machine
     * itself. This method is included in order to solve a Naming problem
     * related to the names of the tpcw result files to be transferred to the
     * the master machine.
     */
    public String getHostName(String machineName) {

        int index = machinesList.indexOf(machineName);
        String retVal = null;
        try {
            retVal = ((CmdAgent)(cmdp.get(index))).getHostName();
        }
        catch (RemoteException re) {
            logger.severe("RemoteException " +
                          re.getCause());
            logger.log(Level.FINE, "Exception", re);
        }
        if (retVal == null) {
            return machineName;
        }
        return retVal;
    }

    /**
     * Executes a command from the master's command agent.
     * @param c The command to be executed
     * @return  A handle to the command
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle execute(Command c)
            throws IOException, InterruptedException, RemoteException {
        return execute(master, c);
    }

    /**
     * Executes a command from the remote command agent.
     * @param machine The target machine to execute the command
     * @param c The command to be executed
     * @return  A handle to the command
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle execute(String machine, Command c)
            throws IOException, InterruptedException, RemoteException {
        int index = machinesList.indexOf(machine);
        return ((CmdAgent)(cmdp.get(index))).execute(c);
    }

    /**
     * Executes a command from the remote command agent.
     * @param machines The target machines to execute the command
     * @param c The command to be executed
     * @return  Handles to the command on each of the target machines
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle[] execute(String[] machines, Command c)
            throws IOException, InterruptedException, RemoteException {
        CommandHandle[] result = new CommandHandle[machines.length];
        for (int i = 0; i < machines.length; i++) {
            String machine = machines[i];
            int index = machinesList.indexOf(machine);
            result[i] = ((CmdAgent)(cmdp.get(index))).execute(c);
        }
        return result;
    }

    /**
     * Executes a java command from the master's command agent.
     * @param c The command to be executed
     * @return  A handle to the command
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle java(Command c)
            throws IOException, InterruptedException, RemoteException {
        return java(master, c);
    }
    /**
     * Executes a java command from the remote command agent.
     * @param machine The target machine to execute the command
     * @param c The command to be executed
     * @return  A handle to the command
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle java(String machine, Command c)
            throws IOException, InterruptedException, RemoteException {
        int index = machinesList.indexOf(machine);
        return ((CmdAgent)(cmdp.get(index))).java(c);
    }

    /**
     * Executes a java command from the remote command agent.
     * @param machines The target machines to execute the command
     * @param c The command to be executed
     * @return  Handles to the command on each of the target machines
     * @throws IOException Error communicating with resulting process
     * @throws InterruptedException Thread got interrupted waiting
     * @throws RemoteException If there is a communication error to the
     *                         remote agent
     */
    public CommandHandle[] java(String[] machines, Command c)
            throws IOException, InterruptedException, RemoteException {
        CommandHandle[] result = new CommandHandle[machines.length];
        for (int i = 0; i < machines.length; i++) {
            String machine = machines[i];
            int index = machinesList.indexOf(machine);
            result[i] = ((CmdAgent)(cmdp.get(index))).java(c);
        }
        return result;
    }
    /**
     * Start commands sequentially in foreground on machines
     * The command string should include all stdin, stdout, stderr
     * redirections (if any). Note that files referred in the command
     * should be on the machine on which the command is run.
     * The 'copy' method can be used to transfer files to remote machines.
     * @param machines on which command should be started
     * @param cmd command to be started
     * @param seq flag to indicate if commands should be sequential or parallel
     * @param priority (default or higher priority) for command
     * @return true if all commands completed successfully, else false
     * @see #copy (String, String, String, String, boolean)
     */
    public boolean start(String machines[], String cmd, int seq,
                         int priority) throws Exception {

        boolean exitcode = true;


        for (int i = 0; i<machines.length; i++)
            logger.fine("Starting command = " + cmd +" on machine " + machines[i]);

        if (seq == SEQUENTIAL) {
            /* Start cmd on each m/c in foreground */
            for (int i = 0; i < machines.length; i++) {
                int index = machinesList.indexOf(machines[i]);
                if (((CmdAgent)(cmdp.get(index))).
                        start(cmd, priority) == false)
                    exitcode = false;
            }
        }
        else if (seq == PARALLEL) {
            /* Start cmd on each m/c in parallel, then wait for all */
            String ident = "Generated";
            for (int i = 0; i < machines.length; i++) {

                int index = machinesList.indexOf(machines[i]);

                ((CmdAgent)(cmdp.get(index))).
                        start(cmd, ident, priority);
            }
            for (int i = 0; i < machines.length; i++) {
                int index = machinesList.indexOf(machines[i]);
                if (((CmdAgent)(cmdp.get(index))).wait(ident) == false)
                    exitcode = false;
            }
        }
        return(exitcode);
    }


    /**
     * Start a command on a single machine
     */
    public boolean start(String machine, String command, int seq,
                         int priority) throws Exception {

        String m[] = new String[1];
        m[0] = machine;

        return(start(m, command, seq, priority));
    }

    /**
     * Start commands in background
     *
     * @param machines on which command should be started
     * @param cmd command to be started
     * @param ident to identify this command later
     * @param priority (default or higher priority) for command
     */
    public void start(String machines[], String cmd, String ident,
                      int priority) throws Exception {
        int index;

        for (int i = 0; i < machines.length; i++) {
            if ((machines[i] == null) || (machines[i].equals(""))) {
                continue;
            }
            index = machinesList.indexOf(machines[i]);
            ((CmdAgent)(cmdp.get(index))).start(cmd, ident, priority);
        }
    }

    /**
     * Start command in background and wait for the
     * specified message
     * @param machines on which command should be started
     * @param cmd command to be started
     * @param ident to identify this command later null if you don't want to do wait
     *              or kill the process when the cmdAgent exits.
     * @param msg message message to which wait for
     * @param priority (default or higher priority) for command
     */
    public void start(String machines[], String cmd, String ident, String msg,
                      int priority) throws Exception {

        for (int i = 0; i < machines.length; i++) {

            if ((machines[i] == null) || (machines[i].equals("")))
                continue;

            int index = machinesList.indexOf(machines[i]);
            boolean ret = ((CmdAgent)(cmdp.get(index))).
                    start(cmd, ident, msg, priority);
            if(ret)
                logger.fine("Started command " + cmd + " on machine " + machines[i]);
            else
                logger.severe("command " + cmd + " on machine " + machines[i] + " failed");
        }
    }

    /**
     * Start a command in background on a single machine
     */
    public void start(String machine, String command, String ident,
                      int priority ) throws Exception {
        String m[] = new String[1];
        m[0] = machine;
        start(m, command, ident, priority);
    }


    /**
     * Start a  command in background and returning the first line of output.
     *
     * @param machine name of the machine on which to start the command
     * @param command to start
     * @param ident identifier to associate with this command
     * @param priority in which to run command
     * @return String the first line of output from the command
     */
    public String startAndGetOneOutputLine(String machine, String command,
                                           String ident, int priority)
            throws Exception {

        logger.info("starting command = "
                    + command + " on machine = " + machine);
        int index = machinesList.indexOf(machine);
        String retVal = ((CmdAgent)(cmdp.get(index))).
                startAndGetOneOutputLine(command, ident, priority);
        return retVal;
    }



    /**
     * Start a command in foreground and returning the stdout.
     *
     * @param machine name of the machine on which to start the command
     * @param command to start
     * @param priority in which to run command
     * @return String the standard output from the command
     */
    public String startAndGetStdOut (String machine, String command, int priority)
            throws Exception {

        // logger.fine ("starting command = " + command + " on machine = " + machine);
        int index = machinesList.indexOf(machine);
        String retVal = ((CmdAgent)(cmdp.get(index))).
                startAndGetStdOut(command, priority);
        return retVal;
    }



    public void startJavaCmd(String machines[], String cmd,
                             String ident, String env[]) throws Exception {


        for (int i = 0; i < machines.length; i++) {
            if ((machines[i] == null) || (machines[i].equals(""))) {
                continue;
            }
            logger.fine("Starting JAVA with " + cmd + " on " + machines[i]);
            int index = machinesList.indexOf(machines[i]);
            ((CmdAgent)(cmdp.get(index))).startJavaCmd(cmd, ident, env);
        }
    }

    /**
     * Start the agent on a single machine
     */
    public boolean startAgent(String machine, Class agentClass, String identifier) throws Exception {

        String m[] = new String[1];
        m[0] = machine;

        return(startAgent(m, agentClass, identifier));
    }

    /**
     * Start Agent in the specified machines.
     *
     * @param machines on which command should be started
     * @param agentClass Impl Class of the agent to be started
     * @param identifier to identify this agent later
     */
    public boolean startAgent(String machines[], Class agentClass, String identifier) throws Exception {
        int index;
        boolean result = true;

        for (int i = 0; i < machines.length; i++) {
            if ((machines[i] == null) || (machines[i].equals(""))) {
                continue;
            }
            index = machinesList.indexOf(machines[i]);

            if (index == -1) {
                StringBuilder listString = new StringBuilder();
                for (int j = 0; j < machinesList.size(); j++) {
                    listString.append(machinesList.get(j));
                    listString.append(' ');
                }
                logger.severe("Machine " + machines[i] +
                              " not in machine list.\nMachine list: " +
                              listString.toString());
            }
            //Change the identifier to agent@host
            result = result && ((CmdAgent)(cmdp.get(index))).startAgent(agentClass, identifier + "@" + machines[i]);
        }
        return result;
    }


    /**
     * Wait for command started earlier in background
     * This method calls wait on all the CmdAgent objects for
     * the listed machines
     *
     * @param machine on which to wait
     * @param ident used to identify command in 'start' call
     * @return true if command finished succesfully
     */
    public boolean wait(String machine, String ident) throws Exception {
        boolean exitcode = true;
        logger.info("Waiting for " + ident + " to complete ");
        int index = machinesList.indexOf(machine);
        if (((CmdAgent)(cmdp.get(index))).wait(ident) == false)
            exitcode = false;
        return(exitcode);
    }

    /**
     * Wait for command started earlier in background
     * This method calls wait on all the CmdAgent objects for
     * the listed machines
     *
     * @param machines on which to wait
     * @param ident used to identify command in 'start' call
     * @return true if command finished succesfully on all machines
     */
    public boolean wait(String machines[], String ident) throws Exception {
        boolean exitcode = true;
        for (int i = 0; i < machines.length; i++) {
            if(wait(machines[i], ident) == false)
                exitcode = false;
        }
        return(exitcode);
    }

    /**
     * Kill command started earlier in background
     * This method calls kill on all the CmdAgent objects for
     * the listed machines
     * @param machines on which to issue kill
     * @param ident used to identify command in 'start' call
     */
    public void kill(String machines[], String ident) {
        try {
            for (int i = 0; i < machines.length; i++) {
                int index = machinesList.indexOf(machines[i]);
                ((CmdAgent)(cmdp.get(index))).kill(ident);
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Failed to kill " + ident, e);
        }
    }


    /**

     * Kill command started earlier in background using the killem script.
     * This method calls killem on all the CmdAgent objects for
     * the listed machines.
     * @param machines on which to issue kill
     * @param ident identifier if any if this process was previously started
     *              through the CmdService.
     * @param processString search string to grep the process while killing
     *                      (same as in killem)
     * @param sigNum the signal number to be used to kill.
     *
     */
    public void killem(String machines[], String ident, String processString, int sigNum) {
        try {
            for (int i = 0; i < machines.length; i++) {
                int index = machinesList.indexOf(machines[i]);
                ((CmdAgent)(cmdp.get(index))).killem(ident,
                        processString,
                        sigNum);
                logger.info("killed " + processString +
                        " on machine " + machines[i]);
            }
        } catch (Exception e) { }
    }

    /**
     * Gets a property from a given file
     * @param machine The machine name
     * @param propFile The property file name
     * @param propName The property key name
     * @return The property value
     * @throws java.io.IOException If there is an error accessing the config file
     */
    public String getProperty(String machine, String propFile, String propName)
            throws IOException {
        int idx = machinesList.indexOf(machine);
        if (idx == -1)
            throw new IOException(machine + " not in list of machines.");
        FileAgent agent = (FileAgent) filep.get(idx);
        return agent.getProperty(propFile, propName);
    }


    /**
     * Kill all commands currently running and cleanup
     * This method is called when a run must be aborted
     * or at the end of a benchmark run.
     */
    public void kill() {
        int i = 0;
        try {
            for (i = 0; i < cmdp.size(); i++) {
                logger.info("killing CmdAgent@" + machinesList.get(i));
                ((CmdAgent)(cmdp.get(i))).kill();
            }
            cmdp.clear();
            filep.clear();
        } catch (Exception e) {
            logger.severe("Kill Failed for CmdAgent@" + machinesList.get(i));
            logger.log(Level.FINE, "Exception", e);
        }

        //Exiting RMI registry and Registry
        if (rmi != null)
            try {
                rmi.destroy();
            } catch (RemoteException e) {
                logger.log(Level.SEVERE, "Caught RemoteException on local " +
                        "CommandHandle destroy. Please report bug.",e);
            }
    }

    /**
     * Copy a file from one remote machine to another
     * This method essentially does the work of 'rcp'
     * using the FileAgents on the machines
     * @param srcmachine - Name of source machine
     * @param destmachine - Name of destination machine
     * @param srcfile - Name of source file
     * @param destfile - Name of destination file
     * @param append to dest file or overwrite it
     * @return true/false if copy was successful/failed
     */
    public synchronized boolean copy(String srcmachine, String destmachine,
                                     String srcfile, String destfile,
                                     boolean append) {

        FileAgent srcf, destf = null;
        FileService srcfilep = null, destfilep = null;
        int sidx = machinesList.indexOf(srcmachine);
        int didx = machinesList.indexOf(destmachine);
        String buf;
        if (sidx == didx && srcfile.equals(destfile))
            return(true);

        if (srcfile.equals(destfile)){
            try{
                String dest = ((CmdAgent) cmdp.get(sidx)).getHostName();
                String src = ((CmdAgent) cmdp.get(sidx)).getHostName();
                if (dest == src)
                    return true;
            } catch (Exception e) {
                logger.severe("CmdService: Copying - CmdAgent getHostName exception");
                logger.log(Level.FINE, "Exception", e);
            }
        }
        logger.fine("CmdService: Copying " + srcfile + " from " + srcmachine
                + " to " + destfile + " in " + destmachine);

        srcf = (FileAgent)(filep.get(sidx));
        destf = (FileAgent)(filep.get(didx));
        try {
            srcfilep = srcf.open(srcfile, FileAgent.READ);
            if (append)
                destfilep = destf.open(destfile, FileAgent.APPEND);
            else
                destfilep = destf.open(destfile, FileAgent.WRITE);

            // Now loop, reading from src and writing to dest
            while (true) {
                buf = srcfilep.read();
                if (buf == null) // end-of-file
                    break;
                destfilep.write(buf);
            }

            srcfilep.close();
            destfilep.close();
        } catch (Exception ie) {
            logger.severe("CmdService: Could not copy " + srcmachine +
                              ":" + srcfile + " to " + destmachine + ":" + destfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
        return(true);
    }

    public synchronized boolean move(String srcmachine, String destmachine,
                                     String srcfile, String destfile,
                                     boolean append) {
        // First copy the file then delete
        try {
            if(this.copy(srcmachine, destmachine, srcfile, destfile, append)) {
                FileAgent srcf = null;
                int sidx = machinesList.indexOf(srcmachine);
                int didx = machinesList.indexOf(destmachine);
                if (sidx == didx && srcfile.equals(destfile))
                    return(true);
                srcf = (FileAgent)(filep.get(sidx));
                return srcf.removeFile(srcfile);
            }
        }
        catch(Exception ie) {
            logger.severe("CmdService: Could not move " + srcmachine +
                        ":" + srcfile + " to " + destmachine + ":" +
                        destfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
        return false;
    }

    public synchronized boolean delete(String srcmachine, String srcfile) {
        try {
            int sidx = machinesList.indexOf(srcmachine);
            FileAgent srcf = (FileAgent)(filep.get(sidx));
            return srcf.removeFile(srcfile);
        }
        catch(Exception ie) {
                logger.severe("CmdService: Could not delete " + srcmachine +
                        ":" + srcfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
    }


    /**
     * Copy a file from one remote machine to a stream on the master.
     * This method essentially does the work of 'rcp'
     * using the FileAgents on the machines
     * @param srcmachine - Name of source machine
     * @param srcfile - Name of source file
     * @param stream The stream to copy the content to
     * @return true/false if copy was successful/failed
     */
    public synchronized boolean copyToStream(String srcmachine, String srcfile, 
                                             OutputStream stream) {
        FileAgent srcf = null;
        FileService srcfilep = null;
        int sidx = machinesList.indexOf(srcmachine);
        byte[] buf = null;

        //logger.info("CmdService: Copying " + srcfile + " to " + destfile);
        //logger.info("CmdService: Copying from " + srcmachine + " to " + destmachine);

        srcf = (FileAgent)(filep.get(sidx));
        try {
            srcfilep = srcf.open(srcfile, FileAgent.READ);

            // Now loop, reading from src and writing to dest
            while (true) {
                buf = srcfilep.readBytes(1000000);
                //	logger.info("           Read " + buf);
                //	logger.info(buf);
                //		logger.info(buf.length);
                stream.write(buf);
                if (buf.length < 1000000) {
                    break;
                }
            }

            srcfilep.close();
        } catch (Exception ie) {
            logger.severe("CmdService: Could not copy " + srcmachine +
                          ":" + srcfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
        return(true);
    }


    /**
     * Copy a file from one remote machine to another
     * This method essentially does the work of 'rcp'
     * using the FileAgents on the machines
     * @param srcmachine - Name of source machine
     * @param destmachine - Name of destination machine
     * @param srcfile - Name of source file
     * @param destfile - Name of destination file
     * @param append to dest file or overwrite it
     * @return true/false if copy was successful/failed
     */
    public synchronized boolean copyBytes(String srcmachine,
                                          String destmachine,
                                          String srcfile, String destfile,
                                          boolean append) {
        FileAgent srcf, destf = null;
        FileService srcfilep = null, destfilep = null;
        int sidx = machinesList.indexOf(srcmachine);
        int didx = machinesList.indexOf(destmachine);
        byte[] buf = new byte[1000000];

        //logger.info("CmdService: Copying " + srcfile + " to " + destfile);
        //logger.info("CmdService: Copying from " + srcmachine + " to " + destmachine);
        if (sidx == didx && srcfile.equals(destfile))
            return(true);
        srcf = (FileAgent)(filep.get(sidx));
        destf = (FileAgent)(filep.get(didx));
        try {
            srcfilep = srcf.open(srcfile, FileAgent.READ);
            if (append)
                destfilep = destf.open(destfile, FileAgent.APPEND);
            else
                destfilep = destf.open(destfile, FileAgent.WRITE);

            // Now loop, reading from src and writing to dest
            while (true) {
                buf = srcfilep.readBytes(1000000);
                //	logger.info("           Read " + buf);
                //	logger.info(buf);
                //		logger.info(buf.length);
                destfilep.writeBytes(buf, 0 , buf.length);
                if (buf.length < 1000000) {
                    break;
                }
            }

            srcfilep.close();
            destfilep.close();
        } catch (Exception ie) {
            logger.severe("CmdService: Could not copy " + srcmachine +
                          ":" + srcfile + " to " + destmachine + ":" +
                          destfile);
            logger.log(Level.FINE, "Exception", ie);
            return(false);
        }
        return(true);
    }


    /**
     *
     * The hostInterfaces Properties object stores mappings of machine name
     * in the benchmark configuration to the corresponding interface of the
     * master machine used to connect to that machine.
     *
     * @return Properties - the hostInterfaces oject.
     */
    public Properties getHostInterfaces() {
        return hostInterfaces;
    }

    /**
     * Set the Log level for Agents
     * @param name Logger name
     * @param level Log level
     */
    public void setLogLevel(String name, Level level) {
        int i = 0;
        try {
            for (i = 0; i < cmdp.size(); i++) {
                ((CmdAgent)(cmdp.get(i))).setLogLevel(name, level);
            }
        } catch (Exception e) {
            logger.severe(" setLogLevel Failed for CmdAgent@" + machinesList.get(i));
            logger.log(Level.FINE, "Exception", e);
        }
    }

    Registry getRegistry() {
        return registry;
    }
}
